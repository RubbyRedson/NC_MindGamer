//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : AbstractArbiter.java
//  @ Date : 29.10.2013
//  @ Author : 
//
//

package ru.netcracker.education;


import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

class AbstractArbiter {
    private static int RangeHorizontalLow = Integer.MIN_VALUE;
    private static int RangeHorizontalHigh = Integer.MAX_VALUE;
    private static int RangeVerticalLow = Integer.MIN_VALUE;
    private static int RangeVerticalHigh = Integer.MAX_VALUE;
    //private static final int NUMBER_OF_CHANGES_AT_ONCE = 1; //not needed
    private static final long TIMELIMIT = 1000000;
    private static final TimeUnit TU = TimeUnit.SECONDS;
    //public Object Scores;
    public AbstractField Field;
    private Callable<Cell> player1;
    private Callable<Cell> player2;
    private ExecutorService executor = Executors.newFixedThreadPool(2); //тут должно быть кол-во необх тредов для игры
    private FieldCells field1;
    private FieldCells field2;

    public boolean hasWinner(Cell LatestMove) { //тут проверка на победителя
        this.Field.getField().checkHasWinner(LatestMove);
        return false;
    }
    
    public void arrangeMatch() {
        Field = new AbstractField();
        field1 = new FieldCells();
        field2 = new FieldCells();
        player1 = new AbstractGamer(field1);    // тут нужно найти двух ботов
        player2 = new AbstractGamer(field2);
        List<Future<Cell>> players = new ArrayList<Future<Cell>>();
        Cell move;
        while (true) {
            players.add(executor.submit(player1));
            try {
                move = players.get(0).get(TIMELIMIT, TU);
                checkValidityOfMove(move);
                if (hasWinner(move)) {
                    //player 1 won
                    break;
                }
            }
            catch (IllegalArgumentException e) {
                // Winner is player2
            }
            catch (Throwable e) {
                //
            }
            players.add(executor.submit(player2));
            try {
                move = players.get(1).get(TIMELIMIT, TU);
                checkValidityOfMove(move);
                if (hasWinner(move)) {
                    //player 2 won
                    break;
                }
            }
            catch (IllegalArgumentException e) {
                // Winner is player1
            }
            catch (Throwable e) {
                //
            }
        }
        executor.shutdown();
    }
    
    public void checkValidityOfMove(Cell move) throws Exception {
        if (move.getVertical() < RangeVerticalLow || move.getVertical() > RangeVerticalHigh ||
                move.getHorizontal() < RangeHorizontalLow || move.getHorizontal() > RangeHorizontalHigh ||
                this.Field.getField().getCells()[move.getHorizontal()][move.getVertical()].isFilled()) {   //valid coords
            //and if the named cell isn't already filled, the game is Tic-Tac-Toe
                             throw new IllegalArgumentException("Wrong move from player!");
        }
        else {
            updateField(move);
        }
    }

    public void updateField(Cell move) {
        Field.updateField(move);
        field1.UpdateField(move);
        field2.UpdateField(move);
    }

    private boolean checkNumberOfChanges() {
        boolean result = false;
        int changes1 = 0;
        int changes2 = 0;
        for (int i = 0; i < RangeHorizontalHigh; i++) {
            for (int j = 0; j < RangeVerticalHigh; j++) {

            }
        }
        return result;
    }
}
